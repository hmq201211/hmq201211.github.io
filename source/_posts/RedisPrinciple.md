---
title: RedisPrinciple  
date: 2021-01-02  
tags: 
- 中间件
- 数据库
- 消息队列
- 分布式锁
categories:
- 数据库
---


# 线程IO模型
  
## 非阻塞IO
  - 阻塞式IO
    1. 读取多少个字节后返回，要是没读取完成，就会阻塞
    2. 写多少字节返回，要是写缓冲区满了，那么写方法就会阻塞，直到缓冲区有空间空出来
  - 非阻塞式IO Non_Blocking true
    - 读写方法都不会阻塞
    - 能读多少取决于读缓冲区的已有字节数
    - 能写多少取决于写缓冲区的空闲字节数
    - 读写都会返回已经操作的字节数

## 事件轮询
  用来解决线程如何知道何时继续读和写的问题（读缓冲区数据来了，或者写缓冲区有数据空了）
  - 例如select方法可以阻塞timeout事件，来监听任何事件，要是有事件到来了会返回，或者超时了也会返回
  - epoll比select效率要高

## 指令队列
  会为每个客户端套接字关联一个指令队列，客户端的指令通过队列顺序处理

## 响应队列
  同样会为每个客户端关联一个响应队列，通过这个队列来返回结果给客户端
  - 要是队列为空，需要获取写事件，就把当前的客户端fd从write_fds中移除
  - 等有数据了，再把当前的fd加入进去
  - 避免select返回了写事件，但是发现没有数据可以写，造成的cpu浪费

## 定时任务
  防止响应IO事件时错过定时任务，Redis使用了最小堆来处理
  - 每个循环周期中，对最小堆中要到期的时间点的任务进行处理
  - 将最快要执行的任务还需要等待的时间记录下来，作为selct调用的timeout
  
# 通讯协议
  Redis使用了文本协议
  
## RESP Redis序列化协议
  5种最小单元类型，每个单元结束后加上回车换行符
  - 单行字符串以+开头
  - 多行字符串以$开头加上字符串的长度
  - 整数以：开头
  - 错误信息以-开头
  - 数组以*开头加上数组的长度















