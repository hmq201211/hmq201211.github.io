---
title: RedisPrinciple  
date: 2021-01-02  
tags: 
- 中间件
- 数据库
- 消息队列
- 分布式锁
categories:
- 数据库
---


# 线程IO模型
  
## 非阻塞IO
  - 阻塞式IO
    1. 读取多少个字节后返回，要是没读取完成，就会阻塞
    2. 写多少字节返回，要是写缓冲区满了，那么写方法就会阻塞，直到缓冲区有空间空出来
  - 非阻塞式IO Non_Blocking true
    - 读写方法都不会阻塞
    - 能读多少取决于读缓冲区的已有字节数
    - 能写多少取决于写缓冲区的空闲字节数
    - 读写都会返回已经操作的字节数

## 事件轮询
  用来解决线程如何知道何时继续读和写的问题（读缓冲区数据来了，或者写缓冲区有数据空了）
  - 例如select方法可以阻塞timeout事件，来监听任何事件，要是有事件到来了会返回，或者超时了也会返回
  - epoll比select效率要高

## 指令队列
  会为每个客户端套接字关联一个指令队列，客户端的指令通过队列顺序处理

## 响应队列
  同样会为每个客户端关联一个响应队列，通过这个队列来返回结果给客户端
  - 要是队列为空，需要获取写事件，就把当前的客户端fd从write_fds中移除
  - 等有数据了，再把当前的fd加入进去
  - 避免select返回了写事件，但是发现没有数据可以写，造成的cpu浪费

## 定时任务
  防止响应IO事件时错过定时任务，Redis使用了最小堆来处理
  - 每个循环周期中，对最小堆中要到期的时间点的任务进行处理
  - 将最快要执行的任务还需要等待的时间记录下来，作为selct调用的timeout
  
# 通讯协议
  Redis使用了文本协议
  
## RESP Redis序列化协议
  5种最小单元类型，每个单元结束后加上回车换行符
  - 单行字符串以+开头
  - 多行字符串以$开头加上字符串的长度
  - 整数以：开头
  - 错误信息以-开头
  - 数组以*开头加上数组的长度

## 持久化
- 快照 RDB
  - 全量备份
  - 内存数据的二进制序列化
  - 在进行rdb持久化的时候调用系统的glibc的函数fork来产生子进程，由子进程完全负责持久化的进行
  - 子进程和父进程完全共享代码段和数据段
  - 采用copy on write的机制，父进程在对内存进行修改的时候复制出要修改的内存的那一页，这样最多有2倍的数据内存大小
  - 子进程在进程产生的一瞬间，数据就不会变化，只需要遍历持久化就行
- AOF
  - 存储的是顺序指令序列，只存修改的操作
  - 恢复的时候通过重放这些指令来实现数据恢复
  - 但是随着Redis的运行，AOF会越来越大，AOF恢复会很耗时
  - AOF重写 bgrewriteaof
    - 开辟一个新的子进程对内存进行遍历
    - 转化成一系列的Redis的操作指令
    - 序列化到一个新的aof日志文件中
    - 再把这段操作时间中的增量AOF日志追加到这个文件中
  - fsync
    - AOF日志是文件形式，当程序对日志进行写操作实际是把内容写到了内核为文件描述符分配的一个内存缓存里面，内核会异步将脏数据刷回硬盘
    - 要是突然宕机这时日志就会丢失
    - glibc中的fsync函数可以将指定文件的内容强制刷回硬盘
    - 但是这是IO操作，很慢，实际生产中一般1s执行一次fsync
  - 从机进行持久化，这是因为从机没有客户端请求的压力，但是要注意数据不一致的情况
  - 混合持久化：RDB恢复加AOF增量日志重放
  
## 管道

    
    
    
    
    
    
    
    
    
    
    
    
    
    













