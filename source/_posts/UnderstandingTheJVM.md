---
title: UnderstandingTheJVM
date: 2021-01-12  
tags:
- JVM
- 虚拟机
---

# 运行时数据区
- 虚拟机栈（线程隔离）
- 本地方法栈（线程隔离）
- 方法区（所有线程共享）
- 堆内存（所有线程共享）
- 程序计数器（线程隔离）

## 程序计数器
当前线程执行的字节码的行号指示器，字节码解释器通过改变这个计数器的值来读取下一条要执行的字节码指令   
是程序控制流的指示器，分支，循环，跳转，异常处理，线程切换都需要这个计数器   
如果执行的是Java代码，则指向了虚拟机字节码的指令的地址  
如果执行的本地方法，则为Undefined  
***在虚拟机规范中唯一不会OOM情况的区域***



## 虚拟机栈
生命周期和线程相同  
描述的Java方法执行时的线程内存模型  
每个方法执行的时候，都会同步创建一个栈帧：
- 局部变量表
    - 存放了基本数据类型
    - 对象引用
        - 一个对象起始地址的引用指针
        - 或者指向一个代表对象的句柄或者其他与此对象相关的位置
    - returnAddress 一条字节码指令的地址
    
- 操作数栈
- 动态链接
- 方法出口
    
局部变量表所需的空间在编译时期完成分配，当进入一个方法时，这个方法在栈帧中需要分配多大的局部变量表是完全确定的  
（槽的数量，1个槽位占位32bit），在方法允许期间不会改变局部变量表的大小  
两种异常：
    - 线程请求的栈深度达到虚拟机允许的深度 - StackOverflowError
    - 栈扩展无法申请到足够的内存 - OutOfMemoryError

## 本地方法栈
与虚拟机栈相似，只不过是为本地方法服务  
也会抛出StackOverflowError和OutOfMemoryError

## Java堆
所有线程共享的一块内存区域，在虚拟机启动时创建  
无论在哪个区域，存储的永远都是对象的实例  
如果在Java堆中没有内存完成实例分配，并且堆也无法再扩展时，抛出OOM异常

## 方法区
存储已被虚拟机加载的类型信息，常量，静态变量，即时编译器编译后的代码缓存  
方法区无法满足新的内存分配需求时，抛出OOM异常

## 运行时常量池
方法区的一部分  
class文件的常量池（字面常量+符号引用）+ 运行时产生的常量（String intern）  
当常量池无法申请到内存时，抛出OOM异常

## 直接内存
并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域  
Native函数直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer来作为这块内存的引用进行操作  
可以避免堆和Native堆来回复制数据  
受到物理内存的限制，也会抛出OOM异常



