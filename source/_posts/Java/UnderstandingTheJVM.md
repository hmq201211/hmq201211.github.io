---
title: UnderstandingTheJVM
date: 2021-01-12  
tags:
- JVM
- 虚拟机
---

# 运行时数据区
- 虚拟机栈（线程隔离）
- 本地方法栈（线程隔离）
- 方法区（所有线程共享）
- 堆内存（所有线程共享）
- 程序计数器（线程隔离）

## 程序计数器
当前线程执行的字节码的行号指示器，字节码解释器通过改变这个计数器的值来读取下一条要执行的字节码指令   
是程序控制流的指示器，分支，循环，跳转，异常处理，线程切换都需要这个计数器   
如果执行的是Java代码，则指向了虚拟机字节码的指令的地址  
如果执行的本地方法，则为Undefined  
***在虚拟机规范中唯一不会OOM情况的区域***



## 虚拟机栈
生命周期和线程相同  
描述的Java方法执行时的线程内存模型  
每个方法执行的时候，都会同步创建一个栈帧：
- 局部变量表
    - 存放了基本数据类型
    - 对象引用
        - 一个对象起始地址的引用指针
        - 或者指向一个代表对象的句柄或者其他与此对象相关的位置
    - returnAddress 一条字节码指令的地址
    
- 操作数栈
- 动态链接
- 方法出口
    
局部变量表所需的空间在编译时期完成分配，当进入一个方法时，这个方法在栈帧中需要分配多大的局部变量表是完全确定的  
（槽的数量，1个槽位占位32bit），在方法允许期间不会改变局部变量表的大小  
两种异常：
    - 线程请求的栈深度达到虚拟机允许的深度 - StackOverflowError
    - 栈扩展无法申请到足够的内存 - OutOfMemoryError

## 本地方法栈
与虚拟机栈相似，只不过是为本地方法服务  
也会抛出StackOverflowError和OutOfMemoryError

## Java堆
所有线程共享的一块内存区域，在虚拟机启动时创建  
无论在哪个区域，存储的永远都是对象的实例  
如果在Java堆中没有内存完成实例分配，并且堆也无法再扩展时，抛出OOM异常

## 方法区
存储已被虚拟机加载的类型信息，常量，静态变量，即时编译器编译后的代码缓存  
方法区无法满足新的内存分配需求时，抛出OOM异常

## 运行时常量池
方法区的一部分  
class文件的常量池（字面常量+符号引用）+ 运行时产生的常量（String intern）  
当常量池无法申请到内存时，抛出OOM异常

## 直接内存
并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域  
Native函数直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer来作为这块内存的引用进行操作  
可以避免堆和Native堆来回复制数据  
受到物理内存的限制，也会抛出OOM异常

# HotSpot虚拟机对象探秘
HotSpot虚拟机在Java堆中对象分配、布局和访问的全过程

## 对象的创建
- 当虚拟机遇到一条字节码new指令时，首先查看这个指令的参数能否在常量池中定位到一个类的符号引用，并检查这个符号引用代表的类是否已被加载、解析和初始化过，要是没有，则先进行类加载
- 类加载检查完成后，虚拟机接着为新生对象分配内存，对象所需的内存大小在类加载完成后便能完全确定，于是为对象分配内存相当于是把一个确定大小的内存块从Java堆中划分出来
    - Bump The Pointer 指针碰撞
        1. Java堆中的内存是绝对规整的
        2. 所有使用过的内存放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器
        3. 分配的内存就是把指针向空闲内存的方向挪动一个对象大小的距离
    - Free List 空闲列表
        1. Java堆中的内存不是规整的
        2. 已使用的内存和未使用的内存交错在一起
        3. 虚拟机维护了一个列表，记录了哪些内存块是可用的
        4. 分配内存的时候会从列表中找到一个足够大的内存空间划分给对象实例，并更新列表上的记录
    - 选择哪种分配方式是由Java堆是否规整决定的，而Java堆是否规整又是由锁采用的垃圾收集器是否带有压缩（compact）功能决定的
        - Serial、ParNew这些带有压缩整理过程的收集器，系统会采用指针碰撞
        - CMS这种基于清楚（Sweep）算法的收集器，理论上只能采用较为复杂的空闲列表
    - 考虑到并发的线程安全问题：
        1. 对分配内存空间的动作进行同步处理，CAS加上失败重试机制
        2. TLAB(Thread Local Allocation Buffer)，每个线程预先在Java堆中分配一小块内存，哪个线程在堆中分配内存，优先在哪个线程的本地缓存区中分配，只有本地缓存区满了，分配新的缓存区的时候才需要同步锁定
- 对分配到的内存空间（但是不包括对象头）都初始化零值，要是在TLAB分配的话，这项工作可以提前到TLAB分配时顺便执行
- 接下来对对象头进行必要地设置，根据虚拟机当前运行状态的不同，如是否启用偏向锁，对象头有不同的设置方式
    - 这个对象是哪个类的实例
    - 如何才能找到类的元数据信息
    - 对象的哈希码（调用hashcode（）的时候才会计算）
    - 对象的GC分代年龄信息
- 最后执行构造函数，即Class文件中的<init>()方法，按照程序员的意愿对对象进行初始化，这样一个真正可用的对象才算完全被构造出来
    
## 对象的内存布局
对象在堆内存中的存储布局可以划分为三个部分：对象头（Header）、实例数据（Instance Data）、和对齐填充（Padding）
- 对象头
    - 一类是用于存储对象自身的运行时数据
        - 包括
            - 哈希码
            - GC分代年龄
            - 锁状态
            - 线程持有的锁
            - 偏向线程ID
            - 偏向时间戳
        - 为了以极小的空间存储更多的数据，根据锁状态标志位的不同，Mark Word表示不同的信息
        ![markword][1]







[1]: /source/images/picture/MarkWord.png



