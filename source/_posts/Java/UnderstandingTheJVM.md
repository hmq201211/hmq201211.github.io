---
title: UnderstandingTheJVM date: 2021-01-12  
tags:

- JVM
- 虚拟机

---

# 运行时数据区

- 虚拟机栈（线程隔离）
- 本地方法栈（线程隔离）
- 方法区（所有线程共享）
- 堆内存（所有线程共享）
- 程序计数器（线程隔离）

## 程序计数器

当前线程执行的字节码的行号指示器，字节码解释器通过改变这个计数器的值来读取下一条要执行的字节码指令   
是程序控制流的指示器，分支，循环，跳转，异常处理，线程切换都需要这个计数器   
如果执行的是Java代码，则指向了虚拟机字节码的指令的地址  
如果执行的本地方法，则为Undefined  
***在虚拟机规范中唯一不会OOM情况的区域***

## 虚拟机栈

生命周期和线程相同  
描述的Java方法执行时的线程内存模型  
每个方法执行的时候，都会同步创建一个栈帧：

- 局部变量表
    - 存放了基本数据类型
    - 对象引用
        - 一个对象起始地址的引用指针
        - 或者指向一个代表对象的句柄或者其他与此对象相关的位置
    - returnAddress 一条字节码指令的地址

- 操作数栈
- 动态链接
- 方法出口

局部变量表所需的空间在编译时期完成分配，当进入一个方法时，这个方法在栈帧中需要分配多大的局部变量表是完全确定的  
（槽的数量，1个槽位占位32bit），在方法允许期间不会改变局部变量表的大小  
两种异常： - 线程请求的栈深度达到虚拟机允许的深度 - StackOverflowError - 栈扩展无法申请到足够的内存 - OutOfMemoryError

## 本地方法栈

与虚拟机栈相似，只不过是为本地方法服务  
也会抛出StackOverflowError和OutOfMemoryError

## Java堆

所有线程共享的一块内存区域，在虚拟机启动时创建  
无论在哪个区域，存储的永远都是对象的实例  
如果在Java堆中没有内存完成实例分配，并且堆也无法再扩展时，抛出OOM异常

## 方法区

存储已被虚拟机加载的类型信息，常量，静态变量，即时编译器编译后的代码缓存  
方法区无法满足新的内存分配需求时，抛出OOM异常

## 运行时常量池

方法区的一部分  
class文件的常量池（字面常量+符号引用）+ 运行时产生的常量（String intern）  
当常量池无法申请到内存时，抛出OOM异常

## 直接内存

并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域  
Native函数直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer来作为这块内存的引用进行操作  
可以避免堆和Native堆来回复制数据  
受到物理内存的限制，也会抛出OOM异常

# HotSpot虚拟机对象探秘

HotSpot虚拟机在Java堆中对象分配、布局和访问的全过程

## 对象的创建

- 当虚拟机遇到一条字节码new指令时，首先查看这个指令的参数能否在常量池中定位到一个类的符号引用，并检查这个符号引用代表的类是否已被加载、解析和初始化过，要是没有，则先进行类加载
- 类加载检查完成后，虚拟机接着为新生对象分配内存，对象所需的内存大小在类加载完成后便能完全确定，于是为对象分配内存相当于是把一个确定大小的内存块从Java堆中划分出来
    - Bump The Pointer 指针碰撞
        1. Java堆中的内存是绝对规整的
        2. 所有使用过的内存放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器
        3. 分配的内存就是把指针向空闲内存的方向挪动一个对象大小的距离
    - Free List 空闲列表
        1. Java堆中的内存不是规整的
        2. 已使用的内存和未使用的内存交错在一起
        3. 虚拟机维护了一个列表，记录了哪些内存块是可用的
        4. 分配内存的时候会从列表中找到一个足够大的内存空间划分给对象实例，并更新列表上的记录
    - 选择哪种分配方式是由Java堆是否规整决定的，而Java堆是否规整又是由锁采用的垃圾收集器是否带有压缩（compact）功能决定的
        - Serial、ParNew这些带有压缩整理过程的收集器，系统会采用指针碰撞
        - CMS这种基于清楚（Sweep）算法的收集器，理论上只能采用较为复杂的空闲列表
    - 考虑到并发的线程安全问题：
        1. 对分配内存空间的动作进行同步处理，CAS加上失败重试机制
        2. TLAB(Thread Local Allocation Buffer)
           ，每个线程预先在Java堆中分配一小块内存，哪个线程在堆中分配内存，优先在哪个线程的本地缓存区中分配，只有本地缓存区满了，分配新的缓存区的时候才需要同步锁定
- 对分配到的内存空间（但是不包括对象头）都初始化零值，要是在TLAB分配的话，这项工作可以提前到TLAB分配时顺便执行
- 接下来对对象头进行必要地设置，根据虚拟机当前运行状态的不同，如是否启用偏向锁，对象头有不同的设置方式
    - 这个对象是哪个类的实例
    - 如何才能找到类的元数据信息
    - 对象的哈希码（调用hashcode（）的时候才会计算）
    - 对象的GC分代年龄信息
- 最后执行构造函数，即Class文件中的<init>()方法，按照程序员的意愿对对象进行初始化，这样一个真正可用的对象才算完全被构造出来

## 对象的内存布局

对象在堆内存中的存储布局可以划分为三个部分：对象头（Header）、实例数据（Instance Data）、和对齐填充（Padding）

- 对象头（32bits或者64bits）
    - 一类是用于存储对象自身的运行时数据
        - 包括
            - 哈希码
            - GC分代年龄
            - 锁状态
            - 线程持有的锁
            - 偏向线程ID
            - 偏向时间戳
        - 为了以极小的空间存储更多的数据，根据锁状态标志位的不同，Mark Word表示不同的信息
          ![markword][1]

    - 另一部分是Klass，即对象指向它的类型元数据的指针
    - 如果对象是数组，还有一部分记录数组的长度

- 实例数据部分
- 对齐填充，对象的起始地址必须是8个字节的整数倍，对象头已经对齐了，要是实例数据部分没有对齐，就通过对齐填充来补全

## 对象的访问定位

- 句柄
    - java堆中划分出一块内存作为句柄池
    - reference指向对象的句柄地址
    - 句柄中包含了对象实例数据与类型数据各自具体的地址信息
    - ***优势：reference存储的是稳定句柄地址，而对象被移动（GC时发生）只会改变句柄中的实例数据指针***

- 直接指针访问
    - reference存储的就是对象的地址
    - 这样对象的内存布局就要必须考虑如何放置访问类型数据的相关信息
    - ***优势：访问时间快，节省了一次指针定位的时间开销***

# 垃圾收集器与内存分配策略

## 对象是否可被回收

- 引用计数法
    - 每个对象维护一个被引用的次数，要是对象被引用的次数为0，表示这个对象可以被回收
    - ***问题：无法解决A引用B，B引用A这种循环引用***

- 可达性分析
    - 过程：
        - 定义GC Roots根对象
        - 从这些节点开始，通过引用关系向下搜索
        - 搜索过程走过的路径称为引用链（Reference Chain）
        - 要是某个对象到GC Roots直接没有任何引用链相连的时候，认为这个对象是不可能再被使用的
    - 可以作为GC Roots的对象
        - 虚拟机栈->栈帧->本地变量表中引用的对象（线程被调用的方法堆栈中使用到的参数、局部变量、临时变量）
        - 本地方法栈中JNI （Native方法）引用的对象
        - 方法区中类静态属性引用的对象 （Java类的引用类型静态变量）
        - 方法区中常量引用的对象 （字符串常量池里的引用）
        - Java虚拟机内部的引用 （基本数据类型对应的Class对象、常驻的异常对象（NPE、OOM）、系统类加载器）
        - 所有被同步锁（Synchronized）持有的对象
        - 反应JVM内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存
    - 除了固定的GC Roots对象以外，根据用户所选用的垃圾收集器以及当前回收的内存区域不同，可以有其他对象"临时性"加入
        - ***分代收集和局部回收，只对Java堆中的某一块区域进行垃圾收集时，要考虑这个区域里的对象完全有可能被位于堆中其他区域的对象所引用，这时候就需要将这些关联区域的对象也一并加入GC Roots中***

- 对象的引用
    - 强引用 无论什么情况，只要强引用关系还存在，垃圾收集器就永远不会回收被引用的对象
    - 软引用 描述一些还有用，但是并非必要的对象。在系统将要发现内存溢出异常时，会把这些软引用对象列进回收范围进行二次回收，要是这次回收还是没有足够的内存，才会抛出内存溢出异常
    - 弱引用 跟软引用类似，但是更弱。在垃圾手机钱包工作时，无论内存是否足够，都会回收掉只被弱引用关联的对象
    - 虚引用 一个对象的生存时间跟是否有虚引用无关，也无法通过虚引用获取一个对象实例，设置虚引用的目的是为了在对象被GC时收到一个系统通知

- 可达性分析的两次标定
    - 对象在被可达性分析标记为被回收对象时,回收不会立即执行,而是先判断是否需要执行对象的finalize方法(对象没有覆盖或者虚拟机已经调用过了则视为没必要执行)
      ,要是需要执行则把该对象加入F-Queue队列中,由Finalizer线程执行这些对象的finalize方法
    - ***注意这里只是说触发这个方法的执行,但是并不保证方法会执行完成, 防止执行缓慢或者死循环导致了回收子系统崩溃***
    - 之后收集器会对F-Queue里面的对象进行二次标定,要是这次还是没有引用链存在,该对象即要被回收,要是有了引用链的存在(比如在finalize方法里面把this赋值给了引用链上的对象)
      ,则第二次标定的时候会把该对象移除即将被回收集合
    - finalize是对象逃离被回收的最后机会
    - 但是finalize方法运行代价高昂,不确定性大,无法保证各个对象的调用顺序,不建议使用

- 回收方法区
    - 废弃的常量(类(接口),方法,字段的符号引用也与此类似)
        - 以字符串常量为例,已经没有任何字符串对象引用常量池的常量
        - 且虚拟机中也没有其他地方引用这个字面量

    - 不再使用的类
        - 该类的所有实例都已经被回收
        - 加载该类的类加载器已经被回收
        - 该类的Class对象没有在任何地方被引用,也不能在任何地方通过反射调用该类的方法
        - ***在大量使用反射、动态代理、动态生成JSP以及OSGi这类频繁自定义类加载器的场景下，需要jvm具备类型卸载能力***

- 垃圾收集算法
    - 分代收集理论
        - 弱分代假说: 绝大多数对象都是朝生夕灭的
        - 强分代假说: 熬过很多次垃圾收集过程的对象越难以消亡
        - 弱分代和强分代假说奠定了分代收集的理论基础,也同时带来了问题: 新生代的对象可能被老年代引用
        - 跨代引用假说: 跨代引用相对于同代引用的来说是占极少数的
        - 在新生代建立remember set, 这个结构把老年代分成很多块, 标记出老年代的哪一块内存会存在跨代引用, 在Minor GC的时候, 把存在跨代引用的小块内存中的对象加入到GC Roots中
        - 名词解释
            - Partial GC ： 不是完整收集整个Java堆的垃圾收集
                - Minor GC、 Young GC 新生代的垃圾收集
                - Major GC、 Old GC 老年代垃圾收集（CMS）
                - Mixed GC 收集整个新生代和部分老年代的垃圾收集（G1）
            - Full GC：收集整个堆和方法区
    -

[1]: /images/picture/MarkWord.png



