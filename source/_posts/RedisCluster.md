---
title: RedisCluster  
date: 2021-01-06  
tags: 
- 中间件
- 数据库
- 消息队列
- 分布式锁
categories:
- 数据库
---

# 主从同步

## CAP原理
当发生网路分区的时候，一致性和可用性两难全

- C：consistent一致性
- A：availability可用性
- P：partition tolerance分区容忍性

当网路分区发生时，两个不同机器上的节点无法通讯，对一个节点的修改无法同步到另一个节点，数据的一致性无法保证  
除非我们在发生网路分区的时候不提供修改的服务，直到网路恢复再对外提供服务  

## 最终一致性
Redis的主从数据是异步同步的，所以分布式的Redis不满足一致性要求  
Redis保证可用性，因为客户端在Redis的主节点修改了数据后立即返回，即使在主从网路断开的情况下，对外依然可以提供修改服务  
但Redis保证最终一致性，从节点会追赶主节点，包括网路断开又恢复的情况

## 主从同步与从从同步
减轻主节点的压力，支持从节点从从节点同步数据

## 增量同步
主节点同步的是指令流，修改的指令存储到本地内存buffer，然后异步把指令同步给从节点  
从节点会反馈自己的偏移量  
***但是buffer是环形数组，如果满了，后来的指令会覆盖掉之前的指令***  
所以当出现网路不好，从节点无法从主节点复制，当网路恢复的时候，主节点那些没有同步的指令在buffer中可能就已经被后来的指令覆盖掉了

## 快照同步
***耗资源***
- bgsave 立即返回ok，主进程fork出一个子进程，然后继续执行业务，子进程将内存中的数据保存到磁盘中，然后退出
- save 阻塞主进程，直到内存中的数据保存到了磁盘里

快照同步就是先bgsave，然后再把快照文件传送到从节点，从节点收到快照文件，先将内存数据清空，然后全量加载，加载完成后通知主节点后继续增量同步  
注意，这段时间内主节点的增量同步buffer还是在不停的写入，要是快照同步的时间过长，或者buffer太小，就会导致增量同步是吧，导致陷入快照同步的死循环

## 增加从节点
从节点新加入集群时，先执行快照同步，然后再增量同步 

## 无盘复制
快照同步需要很耗时的IO操作，特别是在当系统正在进行AOF的fsync时，发生快照同步，那么fsync会推迟执行，显著影响了服务效率  
无盘复制就是主节点直接通过socket将快照内容发送给从节点，生成快照是遍历过程，主节点一边序列化，一边将序列化的内容发送给从节点  
从节点就是收到所有数据到内存时，再一次性加载  

## wait指令
同步wait之前的所有写操作，异步变成同步，保证强一致性（不严格）  

```shell
wait n t // n代表几个从节点，t代表超时时间 0表示无限等待直到同步完成（要是这时间发生了网路分区，wait指令永远阻塞，丧失可用性）
```

# Sentinel 哨兵
一般是3-5个节点组成的哨兵集群，来监控主从节点的状态  
当主节点挂掉时，自动选一个最优的从节点成为主节点  
客户端来连接的时候会先连接哨兵，然后获取主节点地址，再进行数据交互  
要是主节点挂掉，客户端会重新向哨兵要地址，哨兵会告诉客户端新的主节点地址  
这样就完成了无需重启的节点切换  
当主节点重启来之后，会成为新的主节点的从节点，会从新的主节点同步数据














