---
title: RedisCluster  
date: 2021-01-06  
tags: 
- 中间件
- 数据库
- 消息队列
- 分布式锁
categories:
- 数据库
---

# 主从同步

## CAP原理
当发生网路分区的时候，一致性和可用性两难全

- C：consistent一致性
- A：availability可用性
- P：partition tolerance分区容忍性

当网路分区发生时，两个不同机器上的节点无法通讯，对一个节点的修改无法同步到另一个节点，数据的一致性无法保证  
除非我们在发生网路分区的时候不提供修改的服务，直到网路恢复再对外提供服务  

## 最终一致性
Redis的主从数据是异步同步的，所以分布式的Redis不满足一致性要求  
Redis保证可用性，因为客户端在Redis的主节点修改了数据后立即返回，即使在主从网路断开的情况下，对外依然可以提供修改服务  
但Redis保证最终一致性，从节点会追赶主节点，包括网路断开又恢复的情况

## 主从同步与从从同步
减轻主节点的压力，支持从节点从从节点同步数据

## 增量同步
主节点同步的是指令流，修改的指令存储到本地内存buffer，然后异步把指令同步给从节点  
从节点会反馈自己的偏移量  
***但是buffer是环形数组，如果满了，后来的指令会覆盖掉之前的指令***  
所以当出现网路不好，从节点无法从主节点复制，当网路恢复的时候，主节点那些没有同步的指令在buffer中可能就已经被后来的指令覆盖掉了

## 快照同步
***耗资源***
- bgsave 立即返回ok，主进程fork出一个子进程，然后继续执行业务，子进程将内存中的数据保存到磁盘中，然后退出
- save 阻塞主进程，直到内存中的数据保存到了磁盘里

快照同步就是先bgsave，然后再把快照文件传送到从节点，从节点收到快照文件，先将内存数据清空，然后全量加载，加载完成后通知主节点后继续增量同步  
注意，这段时间内主节点的增量同步buffer还是在不停的写入，要是快照同步的时间过长，或者buffer太小，就会导致增量同步是吧，导致陷入快照同步的死循环

## 增加从节点
从节点新加入集群时，先执行快照同步，然后再增量同步 

## 无盘复制
快照同步需要很耗时的IO操作，特别是在当系统正在进行AOF的fsync时，发生快照同步，那么fsync会推迟执行，显著影响了服务效率  
无盘复制就是主节点直接通过socket将快照内容发送给从节点，生成快照是遍历过程，主节点一边序列化，一边将序列化的内容发送给从节点  
从节点就是收到所有数据到内存时，再一次性加载  

## wait指令
同步wait之前的所有写操作，异步变成同步，保证强一致性（不严格）  

```shell
wait n t // n代表几个从节点，t代表超时时间 0表示无限等待直到同步完成（要是这时间发生了网路分区，wait指令永远阻塞，丧失可用性）
```

# Sentinel 哨兵
一般是3-5个节点组成的哨兵集群，来监控主从节点的状态  
当主节点挂掉时，自动选一个最优的从节点成为主节点  
客户端来连接的时候会先连接哨兵，然后获取主节点地址，再进行数据交互  
要是主节点挂掉，客户端会重新向哨兵要地址，哨兵会告诉客户端新的主节点地址  
这样就完成了无需重启的节点切换  
当主节点重启来之后，会成为新的主节点的从节点，会从新的主节点同步数据

# Cluster 集群

## 特点
- 去中心化
- 分节点
- 每个节点负责集群的一部分数据
- 多个节点相互连接组成一个对等的集群
- 节点之间通讯采用特殊的二进制交互集群信息
- 所有数据分成16384个槽位，槽位的信息存在每个节点中
- 客户端来连接集群时，获取到了分槽的信息，这样要查找key的时候可以直接定位节点
- 这样客户端是缓存了一份Cluster的节点信息，需要纠正机制保证同步
- Cluster的每个节点将集群的配置信息持久化到了配置文件中，需要保证配置问价可写

## 槽位定位算法
1. key->crc16->%16384
2. 还允许用户强制把某个key挂在特定槽位上，需要tag标记

## 跳转 
- 客户端向错误的节点发送指令之后，这个节点发现这个key所在的槽位不属于自己管理，就返回个客户端错误信息；  
- 这个信息包括目标节点的地址和槽位（-MOVED 3999 127.0.0.1:6381 // 3999是槽位 后面是目标节点的地址）  
- 客户端收到这个错误信息后会更新本地的槽位映射表

## 迁移
- 最小单位是槽
- 迁移之前，标注源节点槽位为migrating，目标节点槽位为importing，表示这两个槽位为中间过渡状态
- redis-trib 获取源节点的所有key列表（keysinslot，也可以部分获取），然后逐个key进行迁移
  1. 源节点作为目标节点的客户端
  2. 源节点对key执行dump获得序列化内容
  3. 然后通过客户端向目标节点发送restore 挂这个序列化内容为参
  4. 目标节点反序列化内容到内存中，向客户端返回OK
  5. 源节点删除该key
- 迁移过程是同步的，也就是阻塞的，所以key要尽量小，否则会对性能有影响
- 要是迁移过程中出现了网络故障，这两个节点仍是中间过渡状态，等到迁移工具重新连上的时候会提示用户继续进行迁移
- 迁移过程中客户端的访问：
  1. 访问旧节点，要是存在，正常返回
  2. 要是不存在，可能key就是不存在，还有可能在新节点上
  3. 向客户端返回-ASK targetNodeAddr指令，客户端向目标节点发送ASKING（无参）指令，这个指令要求目标节点对于下一条指令不能不管，当成自己的槽位处理
  4. 然后在目标节点再重新执行原先的指令
      
         这是考虑到迁移没完成之前，这个槽位不属于新节点管理，新节点不认这个key是自己的，于是向客户端返回-MOVED错位指令，让他去源节点执行
         这样就构成了重定向循环
  

## 容错
- 每个节点都可以设置从节点，当某个主节点发送错位，集群会选一个它的从节点成为主节点
- 要是主节点没有从节点，集群将不可用
- 设置cluster-require-full-coverage参数，允许部分节点发生故障，其他节点还可以继续对外访问

## 网络抖动
- cluster-node-timeout 当某个节点持续timeout的时间失联，才认为这个节点出现了故障，才会进行主从切换（主从切换是数据复制的过程）
- cluster-slave-validity-factor 
  - 为0时 主从切换不会抗拒网络抖动
  - 大于1时，作为主从切换的松弛系数

## 可能下线（PFail）于确定下线（Fail）
由于Redis Cluster是去中心化的，一个节点认为一个节点是失联的不代表所有的节点都认为这个节点失联了，需要个协商的过程，大多数节点都认为

  
  
  
  
  
  
  
  
  
  
  
  












